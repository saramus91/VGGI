var vertexShaderSource = `
attribute vec3 aVertexPosition;
attribute vec3 aVertexNormal;
attribute vec2 aTexCoord;
attribute vec3 aTangent;
attribute vec3 aBitangent;

uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat3 uNormalMatrix;
uniform vec2 uTexPivot;
uniform float uTexScale;

varying vec2 vTexCoord;
varying vec3 vT;
varying vec3 vB;
varying vec3 vN;
varying vec3 vPosWorld;

void main(void) {
    vec4 vertexPositionWorld4 = uModelMatrix * vec4(aVertexPosition,1.0);
    vPosWorld = vertexPositionWorld4.xyz;

    vec3 N = normalize(uNormalMatrix * aVertexNormal);

    vec3 T = normalize(uNormalMatrix * aTangent);
    vec3 B = normalize(uNormalMatrix * aBitangent);


    T = normalize(T - dot(T,N)*N);
    B = cross(N, T);

    vT = T;
    vB = B;
    vN = N;

    vec2 shiftedTex = aTexCoord - uTexPivot;
    vTexCoord = uTexPivot + uTexScale * shiftedTex;

    vec4 vertexPositionEye = uViewMatrix * vertexPositionWorld4;
    gl_Position = uProjectionMatrix * vertexPositionEye;
}
`;

var fragmentShaderSource = `
#ifdef GL_FRAGMENT_PRECISION_HIGH
   precision highp float;
#else
   precision mediump float;
#endif

uniform vec3 uLightPosWorld;

uniform sampler2D uDiffuseMap;
uniform sampler2D uSpecularMap;
uniform sampler2D uNormalMap;

varying vec2 vTexCoord;
varying vec3 vT;
varying vec3 vB;
varying vec3 vN;
varying vec3 vPosWorld;

void main(void) {
    mat3 TBN = mat3(vT, vB, vN);

    vec3 normalMapVal = texture2D(uNormalMap, vTexCoord).rgb;
    vec3 N = normalize(TBN * (normalMapVal * 2.0 - 1.0));

    vec3 L = normalize(uLightPosWorld - vPosWorld);
    vec3 V = normalize(-vPosWorld);
    vec3 R = reflect(-L, N);

    vec3 diffuseColor = texture2D(uDiffuseMap, vTexCoord).rgb;
    vec3 specularColor = texture2D(uSpecularMap, vTexCoord).rgb;

    vec3 ambientColor = vec3(0.1, 0.1, 0.1);

    float lambert = max(dot(N,L), 0.0);
    float spec = 0.0;
    if(lambert > 0.0) {
        spec = pow(max(dot(R,V),0.0), 20.0);
    }

    vec3 color = ambientColor + diffuseColor * lambert + specularColor * spec;
    gl_FragColor = vec4(color,1.0);
}
`;


var pivotVertexShaderSource =`
attribute vec3 aVertexPosition;

uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uProjectionMatrix;

void main(void) {
   gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition,1.0);
}
`;

var pivotFragmentShaderSource =
`#ifdef GL_FRAGMENT_PRECISION_HIGH
   precision highp float;
#else
   precision mediump float;
#endif

void main(void) {
   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}
`;
